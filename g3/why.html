
<head><style>
    body        { background: #fff; text-color: #000; margin-left:  40px;   font-size:  0.9em;  font-family: sans-serif; max-width: 800px; }
    h1          { background: #ffb; text-color: #000; margin-left: -30px;   border-top:    5px  solid #ccc; }
    h2          { background: #ffb; text-color: #000; margin-left: -20px;   border-top:    3px  solid #ddd; }
    h3          { background: #ffb; text-color: #000; margin-left: -10px; }
    h4          { background: #ffb; text-color: #000; }
    code        { font-size:    1.1em;  background:  #ddf; text-color: #000; }
    pre         { margin-left:  2em;    background:  #ddf; text-color: #000; }
    pre code    { font-size:    1.1em;  background:  #ddf; text-color: #000; }
</style></head>

<p style="text-align:center">
    <a href="master-toc.html">master TOC</a>
|
    <a href="index.html">main page</a>
|
    <a href="index.html#license">license</a>
</p>
<h1>why might you need gitolite</h1>

<p>Gitolite is separate from git, and needs to be installed and configured.  So...
why do we bother?</p>

<p>Gitolite is useful in any server that is going to host multiple git
repositories, each with many developers, where some sort of access control is
required.</p>

<p>In theory, this can be done with plain old Unix permissions: each user is a
member of one or more groups, each group "owns" one or more repositories, and
using unix permissions (especially the setgid bit -- <code>chmod g+s</code>) you can
allow/disallow users access to repos.</p>

<p>But there are several disadvantages here:</p>

<ul>
<li>Every user needs a userid and password on the server.  This is usually a
killer, especially in tightly controlled environments.</li>
<li>Adding/removing access rights involves complex <code>usermod -G ...</code> mumblings
which most admins would rather not deal with.</li>
<li><em>Viewing</em> (aka auditing) the current set of permissions requires running
multiple commands to list directories and their permissions/ownerships,
users and their group memberships, and then correlating all these
manually.</li>
<li>Auditing historical permissions or permission changes is pretty much
impossible without extraneous tools.</li>
<li>Errors or omissions in setting the permissions exactly can cause problems
of either kind: false accepts or false rejects.</li>
<li>Without going into ACLs it is not possible to give some people read-only
access while some others have read-write access to a repo (unless you make
it world-readable).  Group access just doesn't have enough granularity.</li>
<li>It is absolutely impossible to restrict pushing by branch name or tag
name.</li>
</ul>

<p>Gitolite does away with all this:</p>

<ul>
<li>It uses ssh magic to remove the need to give actual unix userids to
developers.</li>
<li>It uses a simple but powerful config file format to specify access rights.</li>
<li>Access control changes are affected by modifying this file, adding or
removing user's public keys, and "compiling" the configuration.</li>
<li>This also makes auditing trivial -- all the data is in one place, and
changes to the configuration are also logged, so you can audit them.</li>
<li>Finally, the config file allows distinguishing between read-only and
read-write access, not only at the repository level, but at the branch
level within repositories.</li>
</ul>
